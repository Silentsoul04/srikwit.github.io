Managed Code Rootkits: Hooking into Runtime Environments

JVM, CLR <= interpreters on top of OS
		Java bytecode or .NET MSIL will not be understood by CPU

What is a managed code?
	Code that executes under the management of an virtual machine in it's sandbox
Features:
	Write once, run anywhere
		Managed code acts is independent of the underlying platform
		VM acts as a machine specific bridge
		
What is an unmanaged code?
	Code directly executed by the CPU

Java Execution model
1. App
	Java source code -> Compile -> Byetcode
2. Java JVM
	Bytecode is hosted inside the JVM
	JVM loads class libraries from the JARs
	Generates a code using Just In Time Compiler which is machine specific
3. OS
	Machine specific code

.NET Execution model
1. App
	.NET Source code -> Compiler -> Assembly (exe/dll)
2. .NET VM
	Assembly is hosted inside the .NET VM
	Libraries are loaded from the GAC (Global Assembly Cache)
	Generates a code using Just In Time Compiler which is machine specific
3. OS
	Machine specific code


What are Managed Code Rootkits?
	These are user mode application level rootkits inside the managed code environment libraries.
	Target:
		Virtual machines environment of the language providing services to higher level applications
		Hiding informations from the application and logical behavior modification of the application
		Area of influence: applications that run on a specific virtual machine
	Advantages:
		Most security solutions don't look into this behavior because it is difficult to tell which application is performing the malicious activity
		Universal rootkit (depends on the VM's generation of OS specific code)
		Large attack surface (Most systems have atleast one such VM)
		Managed code becomes a part of the OS providing low level access to the attacker


Working with the sandbox to do these modifications requires adminstrative privileges.
Attack scenarios:
 Post exploitation of an external attacker
 Trusted insiders

Attacker install a MCR to:
	Hide process
	Hide files
	Hide network connections
	Install a backdoor for future access
	Manipulate sensitive application logic

MCR implementation:
	1. Non-evasive/by design
		Reusing something present by design
		Example:
			Aspect Oriented Programming by Dynamic Weaving to inject code into applications
			Configuration modification
				Setting an alterntive evil class loader
				Loading a malicious agent
				Library location tampering of machine.config
	2. Evasive
		Direct modification of library intermediate bytecode

Java rootkits:
	Java JVM modification:
		1. Locate the class and extract it
			For PrintStream rt.jar
		2. Dissassemble it (using Jasper disassembler)
		3. Modify the bytecode
		4. Assemble it (using Jasmin assembler)
		5. Deploy the modifed class back to its location

	.NET VM Modification:
		In .NET we have a signature mechanism
		Every assembly has its own signature so you cannot directl modify a dll and put it back
		Disable the signature mechanism?
		Alternative steps:
			1. Locate the assembly in GAC(C:\Windows\Assembly\GAC32) and disassemble it
			2. Modify the MSIL code and re-assemble it
			3. Force the framework to use the modified DLL
			4. Avoid NGEN cached native DLL
				Disable/Replace the old DLL
				ngen uninstall mscorlib
			5. Remove traces with NGEN
		
Provide a malware API to the classes
Inject into the Object class which is inherited by all classes

Some interesting attacks:
	Code manipulation, API hooking
	Authentication backdoors
	Sensitive data theft
	Resource hiding
	Covert channels
	Proxy, DNS fixation
	Polymorphism attacks
	Disabling security mechanisms
	Crypto attacks
	Inspect values
	Permanent any code injection anywhere
	Disable Security Mechanisms
		Run time code authorization
			Java Authentication and Authorization Service
			.NET Code Access Security
		Security logic manipulation
		Result: False sense of security, configuration audit cannot do much
	


